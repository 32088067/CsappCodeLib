负数补码与非的关系：-x=~x+1
第三章第二节：控制

处理器使用流水线（pipelining）来获得高性能，在执行一条指令的部分时，流水线中会充满待执行的指令，处理器会使用分支预测来应对条件跳转的不确定性，如果分支预测错误，处理器必须丢掉为该跳转指令后所有指令已做的工作，会浪费若干个时钟周期导致性能下降
所以对于简单的条件跳转表达式，汇编器会使用条件传送来实现条件分支，也就是先计算条件跳转表达式的结果，再用条件传送指令来实现，如 
	cmovge %rdx,%rax

如何确定分支预测错误的处罚：
	假设预测错误的概率是p,如果没有预测错误，执行代码的时间是Tok，而预测错误的处罚是TMP。那么，作为p的一个函数，执行代码的平均时间是Tavg(p)=(1-p)Tok+p(Tok+TMp)=Tok+pTMp

不是所有的条件跳转都能用条件传送代替：
	1.计算分支结果需要大量计算，当对应条件不满足时，这些工作就白费了
	2.若对（xp?*xp:0）使用条件传送，可能会遇到空指针解引用的错误
	3.提前对分支进行计算可能会改变值
所以两个分支都是简单运算时才会执行优化

除了折叠对比以外的一种实现位模式奇偶校验的方法：
	long val=0;
	while(x){
		val^=x;
		x>>=1;
		val&=1;   //val的最低有效位存储奇偶信息	
	}
折叠对比：
	w=sizeof(int);
	val=val^(x>>(w>>1));	//x>>16
	val=val^(x>>(w>>2));	//x>>8
	val=val^(x>>(w>>3));	//x>>4
	val=val^(x>>(w>>4));	//x>>2
	val=val^(x>>(w>>5));	//x>>1
	val&=1;			//每次折叠，val的每个位都存储了奇偶信息，利用异或的特性，相同的1或相同的0为偶，记为0，而0和1匹配，视为奇，记为1，多次折叠后，最后的val只剩1位，0为偶数个1，1为奇数个1
	
switch语句：
	一步到位，分支跳转时间复杂度为O(1),使用jump table
if-else语句：
	条件遍历，分支跳转时间复杂度为O(n);
如果case值大而稀疏，汇编器转为If-else
如果case值为负数，则加上偏置值
偏置后的开关变量n会创建成一个新的无符号的Index变量，补码表示的负数会被映射成无符号表示的大正数，所以可以通过测试index是否大于m来检测index是否在0-m范围之外  //switch(n){}


第三章第三节：过程
假设过程P调用Q，Q执行后返回到P，这些动作包括下面一个或多个机制：
	传递控制，进入Q时PC设置为Q第一条指令的地址，而从Q返回P时，PC应是P跳转Q时的下一条指令地址
	传递数据，P必须为Q提供一个或多个参数，而Q必须能够向P返回一个值
	分配和释放内存，调用Q时，Q可能需要为局部变量在栈帧stack frame中分配空间，而在Q返回时，必须释放这些空间

x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分被称为过程的栈帧stack frame
通过寄存器过程可以传递最多6个整数值（指针和整数），超过6的参数会在P的栈帧中存储

P使用call调用过程Q时，返回地址A会被压入栈中，而PC会设置为Q的起始地址，当过程Q执行到return时，ret会从栈中弹出地址A，并把PC设置为A

有些时候，局部数据必须存储到内存中：
	1.如果对一个局部变量使用解引用运算符&，则必须为他产生一个地址，因此局部数据会被存储到内存中
	2.如果某些局部变量是数组或结构，而数组或结构必须能够通过数组引用或结构引用访问到，所以也会存储到内存中
	3.寄存器不足够存放所有的本地数据
过程通过减小栈指针在栈上分配空间，因此，栈顶往栈底的地址是逐渐增大的

寄存器是唯一被所有过程共享的资源，虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值
	寄存器%rbx,%rbp和%12~%r15被划分为被调用者保存寄存器，当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的
	而其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器，这意味着任何函数都能修改他们，如果P在调用者寄存器中有局部数据，因为Q可以随意修改这些寄存器，所以调用之前保存好这个数据是P（调用者）的责任
	
正在执行的函数Q的帧：参数构造区，局部变量，被保存的寄存器

栈提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则（后进先出）很自然就与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用（例如，过程P调用Q，Q再调用P）
