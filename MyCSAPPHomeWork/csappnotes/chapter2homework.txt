2024.2.10
作业2-64：
	可以使用！（逻辑非）替代判断
	掩码变量可以命名为mask
	制作连续1接连续0掩码时可以使用-1，因为补码-1表示为全1
	sizeof(int)*8可以表示为sizeof(int)<<3

作业2-66:
	不借助if判断实现位模式的奇校验
	假设int为32位
	如x^=x>>16，对折异或，若奇数位成对出现则为0，若单出现则为1，对折异或后新的x会在奇数位上记录之前的奇偶信息，重复对折，>>8,>>4,>>2,>>1，最后剩下一位数字，与1与，0则偶，1则奇

第三章第一节回忆：
	
	无符号和有符号数的位级表示是相同的
	
	二元操作数中，分为源Source操作数和目的Destination操作数,源操作数可以是立即数Immediate，寄存器Register，内存Memory
	
	地址的表达：
		Imm(Rb,Ri,s)  计算方法是Rb+Ri*s+Imm
		由此特性，指令leaq（送地址至寄存器，目的只能是寄存器）可以替代简单的运算，如12x可以由:
		movq (%rdx,%rdx,2),%rdx;
		leaq (,%rdx,3),%rax;  所表示
	地址表达中的比例因子s为什么只能是1，2，4，8？
		引入数组索引（Array Index）的概念，内存中数组是一块连续的存储空间，如果是			int类型(假设为4字节)，数组索引是以4*i进行访问的，若为long型数字，则需要放缩到8*i来进行访问
	
	最特殊的寄存器是%rsp，它存放栈指针，x86-64中，栈指针是向低地址方向增长，所以压栈是减少栈指针(%rsp)的值
	
	当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应先改变大小，而在unsigned char类型转long时，编译器会使用%eax而非%rax来存储扩展后的unsigned char值，是因为任何为寄存器生成32位值的指令都会把高32位置为0，所以用%eax存放值会更快，而将寄存器的值写入内存时，寄存器的部分可以是(%rax,%eax,%ax,%al)，两者可以互不相同，例如：
		unsigned char值地址在%rdi
		long类型值地址在%rsi
		movzbl (%rdi),%eax
		movq %rax,(%rsi)
		
	x86-64指令集提供了两条不同的单操作数乘法指令，mulq处理无符号数乘法。imulq处理补码乘法，他们都要求一个参数必须在寄存器%rax中；指令imulq有两种不同的形式，一是64位截断，二是扩展到128位，高64位存储在rdx，低64位存储在rax，，编译器会计算操作数的数目分辨使用哪条指令
	
	使用x86-64,函数参数总是出现在特定的寄存器中，%rdi将是第一个参数寄存器，%rsi是第二个，最多可以是六个
